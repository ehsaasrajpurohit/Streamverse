{"ast":null,"code":"import { useMemo, useRef } from 'react';\nimport { useSubscription } from 'use-subscription';\nimport useIsomorphicLayoutEffect from 'use-isomorphic-layout-effect';\nimport { isActorWithState } from './useActor';\nimport { getServiceSnapshot } from './useService';\n\nfunction isService(actor) {\n  return 'state' in actor && 'machine' in actor;\n}\n\nvar defaultCompare = function (a, b) {\n  return a === b;\n};\n\nvar defaultGetSnapshot = function (a) {\n  return isService(a) ? getServiceSnapshot(a) : isActorWithState(a) ? a.state : undefined;\n};\n\nexport function useSelector(actor, selector, compare, getSnapshot) {\n  if (compare === void 0) {\n    compare = defaultCompare;\n  }\n\n  if (getSnapshot === void 0) {\n    getSnapshot = defaultGetSnapshot;\n  }\n\n  var latestSelectorRef = useRef(selector);\n  var subscription = useMemo(function () {\n    var snapshot = getSnapshot(actor);\n    var current = selector(snapshot);\n    var notifySubscriber;\n    return {\n      getSnapshot: function () {\n        return snapshot;\n      },\n      getCurrentValue: function () {\n        return current;\n      },\n      setCurrentValue: function (newCurrent) {\n        current = newCurrent;\n        notifySubscriber === null || notifySubscriber === void 0 ? void 0 : notifySubscriber();\n      },\n      subscribe: function (callback) {\n        notifySubscriber = callback;\n        var sub = actor.subscribe(function (emitted) {\n          snapshot = emitted;\n          var next = latestSelectorRef.current(emitted);\n\n          if (!compare(current, next)) {\n            current = next;\n            callback();\n          }\n        });\n        return function () {\n          sub.unsubscribe();\n        };\n      }\n    }; // intentionally omit `getSnapshot` and `compare`\n    // - `getSnapshot`: it is only supposed to read the \"initial\" snapshot of an actor\n    // - `compare`: is really supposed to be idempotent and the same throughout the lifetime of this hook (the same assumption is made in React Redux v7)\n  }, [actor]);\n  var currentSelected = useSubscription(subscription);\n  var currentChanged = false;\n\n  if (latestSelectorRef.current !== selector) {\n    var selected = selector(subscription.getSnapshot());\n\n    if (!compare(currentSelected, selected)) {\n      currentChanged = true;\n      currentSelected = selected;\n    }\n  }\n\n  useIsomorphicLayoutEffect(function () {\n    latestSelectorRef.current = selector; // this condition should not be required, but setState bailouts are currently buggy: https://github.com/facebook/react/issues/22654\n\n    if (currentChanged) {\n      // required so we don't cause a rerender by setting state (this could create infinite rerendering loop with inline selectors)\n      // at the same time we need to update the value within the subscription so new emits can compare against what has been returned to the user as current value\n      subscription.setCurrentValue(currentSelected);\n    }\n  });\n  return currentSelected;\n}","map":{"version":3,"names":["useMemo","useRef","useSubscription","useIsomorphicLayoutEffect","isActorWithState","getServiceSnapshot","isService","actor","defaultCompare","a","b","defaultGetSnapshot","state","undefined","useSelector","selector","compare","getSnapshot","latestSelectorRef","subscription","snapshot","current","notifySubscriber","getCurrentValue","setCurrentValue","newCurrent","subscribe","callback","sub","emitted","next","unsubscribe","currentSelected","currentChanged","selected"],"sources":["/Users/ehsaasrajpurohit/Desktop/Streamverse-Avishkar-main/client/node_modules/@xstate/react/es/useSelector.js"],"sourcesContent":["import { useMemo, useRef } from 'react';\nimport { useSubscription } from 'use-subscription';\nimport useIsomorphicLayoutEffect from 'use-isomorphic-layout-effect';\nimport { isActorWithState } from './useActor';\nimport { getServiceSnapshot } from './useService';\nfunction isService(actor) {\n    return 'state' in actor && 'machine' in actor;\n}\nvar defaultCompare = function (a, b) { return a === b; };\nvar defaultGetSnapshot = function (a) {\n    return isService(a)\n        ? getServiceSnapshot(a)\n        : isActorWithState(a)\n            ? a.state\n            : undefined;\n};\nexport function useSelector(actor, selector, compare, getSnapshot) {\n    if (compare === void 0) { compare = defaultCompare; }\n    if (getSnapshot === void 0) { getSnapshot = defaultGetSnapshot; }\n    var latestSelectorRef = useRef(selector);\n    var subscription = useMemo(function () {\n        var snapshot = getSnapshot(actor);\n        var current = selector(snapshot);\n        var notifySubscriber;\n        return {\n            getSnapshot: function () { return snapshot; },\n            getCurrentValue: function () { return current; },\n            setCurrentValue: function (newCurrent) {\n                current = newCurrent;\n                notifySubscriber === null || notifySubscriber === void 0 ? void 0 : notifySubscriber();\n            },\n            subscribe: function (callback) {\n                notifySubscriber = callback;\n                var sub = actor.subscribe(function (emitted) {\n                    snapshot = emitted;\n                    var next = latestSelectorRef.current(emitted);\n                    if (!compare(current, next)) {\n                        current = next;\n                        callback();\n                    }\n                });\n                return function () {\n                    sub.unsubscribe();\n                };\n            }\n        };\n        // intentionally omit `getSnapshot` and `compare`\n        // - `getSnapshot`: it is only supposed to read the \"initial\" snapshot of an actor\n        // - `compare`: is really supposed to be idempotent and the same throughout the lifetime of this hook (the same assumption is made in React Redux v7)\n    }, [actor]);\n    var currentSelected = useSubscription(subscription);\n    var currentChanged = false;\n    if (latestSelectorRef.current !== selector) {\n        var selected = selector(subscription.getSnapshot());\n        if (!compare(currentSelected, selected)) {\n            currentChanged = true;\n            currentSelected = selected;\n        }\n    }\n    useIsomorphicLayoutEffect(function () {\n        latestSelectorRef.current = selector;\n        // this condition should not be required, but setState bailouts are currently buggy: https://github.com/facebook/react/issues/22654\n        if (currentChanged) {\n            // required so we don't cause a rerender by setting state (this could create infinite rerendering loop with inline selectors)\n            // at the same time we need to update the value within the subscription so new emits can compare against what has been returned to the user as current value\n            subscription.setCurrentValue(currentSelected);\n        }\n    });\n    return currentSelected;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}